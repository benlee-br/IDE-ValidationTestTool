using System;
using System.Text;
using System.Collections.Generic;
using System.Collections.Specialized;

namespace BioRad.Common
{
    #region Documentation Tags
    /// <summary>
    /// When requesting a queued, asychronous action, one gets back a listener that contains
    /// a reference to a callback on the client. When the action is completed, the listener
    /// receives a completion event, filters to make certain that it is the action it requested from the
    /// correct source, and fires that callback. The callback then deletes that listener and synchronously
    /// gets the requested data.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <classinformation>
    ///		<list type="bullet">
    ///			<item name="authors">Authors: JLerner</item>
    ///			<item name="review">Last design/code review:</item>
    ///			<item name="conformancereview">Conformance review:</item>
    ///			<item name="requirementid">Requirement ID # : 
    ///				<see href="">Replace this text with ID</see> 
    ///			</item>
    ///			<item name="classdiagram">
    ///				<see href="Reference\FileORImageName">Class Diagram</see> 
    ///			</item>
    ///		</list>
    /// </classinformation>
    /// <archiveinformation>
    ///		<list type="bullet">
    ///			<item name="vssfile">$Workfile: DataStatusListener.cs $</item>
    ///			<item name="vssfilepath">$Archive: /Denali3/Source/Core/Common/ExecutableQueue/DataStatusListener.cs $</item>
    ///			<item name="vssrevision">$Revision: 2 $</item>
    ///			<item name="vssauthor">Last Check-in by:$Author: Dprzyby $</item>
    ///			<item name="vssdate">$Date: 8/04/06 3:24p $</item>
    ///		</list>
    /// </archiveinformation>
    #endregion

	public partial class DataStatusListener 
    {
        #region Constants
        #endregion

        #region Member Data
        /// <summary>
        /// Current status of computation.
        /// </summary>
        private Execution_Constants.CompStatus m_Status = Execution_Constants.CompStatus.Unassigned;
        /// <summary>
        /// Executable object for which it is a listener.
        /// </summary>
        ExecutableObject m_EO = null;
        /// <summary>
        /// Asynchronously executed callback provided by the client.
        /// </summary>
        private AsyncExecutionDelegateNoArgs m_ClientAsyncExecuteCallback;
        /// <summary>
        /// Asynchronously executed callback provided by the client.
        /// </summary>
        private AsyncExecutionDelegate m_ClientAsyncTaggedExecuteCallback;

        /// <summary>
        /// Tracks whether the resources are disposed or not.
        /// </summary>
        private bool m_Disposed = false;
        /// <summary>
        /// Name of owner of computation. When listening for events, we only respond
        /// to that event owner name who generated this listener.
        /// </summary>
        private string m_OwnerName = string.Empty;
        /// <summary>
        /// ID of the computation generated by the Update() call.
        /// </summary>
        private Guid m_ComputationID;
        #endregion

        #region Accessors
        /// <summary>
        /// Gets and Sets status.
        /// </summary>
        public Execution_Constants.CompStatus Status
        {
            get { return m_Status; }
            set { m_Status = value; }
        }
        /// <summary>
        /// Gets computation ID for this DSL object.
        /// </summary>
        public Guid CompID
        {
            get { return m_ComputationID; }
        }
        #endregion

        #region Delegates and Events
        /// <summary>
        /// Delegate that is set by the computation initiator, such as a form, that will
        /// execute once the Completed event has been received. Note that the client callback
        /// might have to call EndInvoke() when finished processing the callback or a resource leak 
        /// will occur.
        /// </summary>
        /// <remarks>
        /// Each method invocation should be independent of others. 
        /// Avoid coupling invocations with shared data. 
        /// If data is to be shared among invocations, you will need to provide a 
        /// proper synchronization mechanism in your implementation.
        /// </remarks>
        public delegate void AsyncExecutionDelegate(Guid compID);

        /// <summary>
        /// Delegate that is set by the computation initiator, such as a form, that will
        /// execute once the Completed event has been received. Note that the client callback
        /// MUST call EndInvoke() when finished prvessing the callback or a resource leak 
        /// will occur.
        /// </summary>
        /// <remarks>
        /// Each method invocation should be independent of others. 
        /// Avoid coupling invocations with shared data. 
        /// If data is to be shared among invocations, you will need to provide a 
        /// proper synchronization mechanism in your implementation.
        /// </remarks>
        public delegate void AsyncExecutionDelegateArgs(ListDictionary arguments);

        /// <summary>
        /// Delegate that is set by the computation initiator, such as a form, that will
        /// execute once the Completed event has been received. Note that the client callback
        /// MUST call EndInvoke() when finished prvessing the callback or a resource leak 
        /// will occur.
        /// </summary>
        /// <remarks>
        /// Each method invocation should be independent of others. 
        /// Avoid coupling invocations with shared data. 
        /// If data is to be shared among invocations, you will need to provide a 
        /// proper synchronization mechanism in your implementation.
        /// </remarks>
        public delegate void AsyncExecutionDelegateNoArgs();

        /// <summary>
        /// Delegate that is set by the computation initiator, such as a form, that will
        /// execute once the Completed event has been received. Note that the client callback
        /// MUST call EndInvoke() when finished prvessing the callback or a resource leak 
        /// will occur.
        /// </summary>
        /// <remarks>
        /// Each method invocation should be independent of others. 
        /// Avoid coupling invocations with shared data. 
        /// If data is to be shared among invocations, you will need to provide a 
        /// proper synchronization mechanism in your implementation.
        /// </remarks>
        public delegate void AsyncExecutionDelegateObjArg(object o);


        #endregion

        #region Constructors and Destructor
        /// <summary>
        /// Default constructor. This cannot be allowed to be called, so we throw an exception.
        /// </summary>
        public DataStatusListener()
        {
            throw new ApplicationException("Null Arguments.");
        }

        /// <summary>
        /// DataStatusListener constructor.
        /// </summary>
        /// <param name="execClientDelegate">Delegate for client (form) to call asynchronously when this event is received.</param>
        /// <param name="eo">Executable object (AnalysisObject) which executes computation and fires events to this listener object when 
        /// the computation is completed. Allows this listener to chain into events to be
        /// notified that the results are Ready, Pending, or Aborted.</param>
        /// <param name="owner">Common name of initiator of action associated with this listener.</param>
        /// <param name="compID">ID of computation. Every time AsynchUpdate is called, an ID is assigned to the
        /// request for a computation.</param>
        public DataStatusListener(AsyncExecutionDelegateNoArgs execClientDelegate, ExecutableObject eo, string owner, Guid compID)
        {

            m_ClientAsyncExecuteCallback = execClientDelegate;
            m_ComputationID = compID;
            m_OwnerName = owner.Clone() as string;
            m_EO = eo;

            // Link in to ExecutionEvent.
            if(eo != null)
                eo.ExecutionStatusEvent += new ExecutableObject.ExecutionStatusEventHandler(StatusEventMsg);
        }

        /// <summary>
        /// DataStatusListener constructor.
        /// </summary>
        /// <param name="execClientDelegate">Delegate for client (form) to call asynchronously when this event is received.</param>
        /// <param name="eo">Executable object (AnalysisObject) which executes computation and fires events to this listener object when 
        /// the computation is completed. Allows this listener to chain into events to be
        /// notified that the results are Ready, Pending, or Aborted.</param>
        /// <param name="owner">Common name of initiator of action associated with this listener.</param>
        /// <param name="compID">ID of computation. Every time AsynchUpdate is called, an ID is assigned to the
        /// request for a computation.</param>
        public DataStatusListener(AsyncExecutionDelegate execClientDelegate, ExecutableObject eo, string owner, Guid compID)
        {

            m_ClientAsyncTaggedExecuteCallback = execClientDelegate;
            m_ComputationID = compID;
            m_OwnerName = owner.Clone() as string;
            m_EO = eo;

            // Link in to ExecutionEvent.
            if (eo != null)
                eo.ExecutionStatusEvent += new ExecutableObject.ExecutionStatusEventHandler(StatusEventMsg);
        }

        #endregion

        #region Methods
        /// <summary>
        /// Shallow clone of object.
        /// </summary>
        /// <returns>Cloned DataStatusListener.</returns>
        public DataStatusListener Clone()
        {
            return this.MemberwiseClone() as DataStatusListener;
        }

        /// <summary>
        /// Explicitly releases all resources used by this object.
        /// </summary>
        public virtual void Dispose()
        {
            if (!m_Disposed)
            {
                // Call the overridden Dispose method that contains common cleanup code
                // Pass true to indicate that it is called from Dispose
                Dispose(true);
                // Prevent subsequent finalization of this object. This is not needed 
                // because managed and unmanaged resources have been explicitly released
                GC.SuppressFinalize(this);
            }
        }
        /// <summary>
        /// Releases the unmanaged resources used by the object and optionally 
        /// releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; 
        /// false to release only unmanaged resources. 
        /// </param>
        /// <remarks>
        /// Dispose(bool disposing) executes in two distinct scenarios.
        /// If disposing equals true, the method has been called directly
        /// or indirectly by a user's code. Managed and unmanaged resources
        /// can be disposed.
        /// If disposing equals false, the method has been called by the 
        /// runtime from inside the finalizer and you should not reference 
        /// other objects. Only unmanaged resources can be disposed.
        /// </remarks>
        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                m_EO.ExecutionStatusEvent -= new ExecutableObject.ExecutionStatusEventHandler(StatusEventMsg);
                m_EO = null;
                m_Disposed = true;
                m_ClientAsyncExecuteCallback = null;
            }
        }

        #endregion

        #region Event Handlers
        /// <summary>
        /// This event handler asynchronously processes the status Ready message sent by the Computation ExecutableObject.
        /// If the event indicates that that the computation has completed and that the results are ready, then
        /// it executes the callback. For example, this could be a call to a form to load the data which is now ready.
        /// </summary>
        /// <param name="sender">Source of event.</param>
        /// <param name="e">Event args.</param>
        private void StatusEventMsg(Object sender, ExecutionStatusEventArgs e)
        {
            // Here we asynchronously execute the callback method from the original 
            // client (i.e. form), that first made the call.
            m_Status = e.Status;
            // Asynchronously execute callback on the client.
            if (e.Status == Execution_Constants.CompStatus.Ready &&
                e.OwnerCommonName.CompareTo(m_OwnerName) == 0 &&
                e.ActionID.CompareTo(m_ComputationID) == 0)
            {
                // Asynchronously execute callback on the client.
                if(m_ClientAsyncTaggedExecuteCallback != null)
                    m_ClientAsyncTaggedExecuteCallback.BeginInvoke(m_ComputationID, null, null);
                    //m_ClientAsyncTaggedExecuteCallback.Invoke(m_ComputationID);
            }
        }

        #endregion

    }
}
